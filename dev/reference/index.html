<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ArrayTools package for Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ArrayTools package for Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../storage/">Array storage</a></li><li><a class="tocitem" href="../indexing/">Array Indexing</a></li><li><a class="tocitem" href="../rubberindex/">Rubber indices</a></li><li><a class="tocitem" href="../broadcasting/">Broadcasting of arrays</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Broadcasting"><span>Broadcasting</span></a></li><li><a class="tocitem" href="#Indexing"><span>Indexing</span></a></li><li><a class="tocitem" href="#Storage"><span>Storage</span></a></li><li><a class="tocitem" href="#Pseudo-arrays"><span>Pseudo-arrays</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/ArrayTools.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>The following provides detailed documentation about types and methods provided by the <code>ArrayTools</code> package. This information is also available from the REPL by typing <code>?</code> followed by the name of a method or a type.</p><h2 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.bcastlazy" href="#ArrayTools.bcastlazy"><code>ArrayTools.bcastlazy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bcastlazy(A, [T=eltype(A),] dims...)</code></pre><p>yields a <em>flat</em> array of type <code>T</code> and dimensions <code>dims</code> whose values are given by <code>A</code> according to type conversion and broadcasting rules (see <code>broadcast</code> method). Compared to <a href="#ArrayTools.bcastcopy"><code>bcastcopy</code></a>, making a copy of <code>A</code> is avoided if it is already an array with the correct type of elements and dimensions or if it can be reshaped (by the <code>reshape</code> method) to the correct type and dimensions. This means that the result may share the same contents as <code>A</code>. Argument <code>A</code> can be a scalar or an array with 1-based indices. The result has 1-based indices and contiguous elements which is suitable for fast linear indexing.</p><p>See also <a href="#ArrayTools.bcastcopy"><code>bcastcopy</code></a>, <a href="#ArrayTools.bcastsize"><code>bcastsize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/broadcasting.jl#L38-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.bcastcopy" href="#ArrayTools.bcastcopy"><code>ArrayTools.bcastcopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bcastcopy(A, [T=eltype(A),] dims...)</code></pre><p>yields a new array of element type <code>T</code> and dimensions <code>dims</code> whose values are given by <code>A</code> according to type conversion and broadcasting rules (like for the <code>broadcast</code> method). Compared to <a href="#ArrayTools.bcastlazy"><code>bcastlazy</code></a>, it is guaranteed that the returned array does not share its contents with <code>A</code>.</p><p>Argument <code>A</code> can be a scalar value or an array.</p><p>See also <a href="#ArrayTools.bcastlazy"><code>bcastlazy</code></a>, <a href="#ArrayTools.bcastsize"><code>bcastsize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/broadcasting.jl#L7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.bcastsize" href="#ArrayTools.bcastsize"><code>ArrayTools.bcastsize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bcastsize(size(A), size(B), ...) -&gt; siz</code></pre><p>yields the size <code>siz</code> of the array that would result from applying broadcasting rules (see <code>broadcast</code> method) to arguments <code>A</code>, <code>B</code>, etc. The result is a tuple of integers (of type <code>Int</code>). Call <a href="#ArrayTools.check_size"><code>check_size</code></a> if you want to also make sure that the result is a list of valid dimensions.</p><p>The method can also be applied to a single dimension:</p><pre><code class="nohighlight hljs">bcastsize(a, b) -&gt; c</code></pre><p>to yield the dimension <code>c</code> gievn by broadcasting dimensions <code>a</code> and <code>b</code> throwing an exception if dimensions are not compatible according to broadcasting rules. This is the same as <code>Base.Broadcasting._bcs1</code> but it takes care of converting to <code>Int</code>.</p><p>See also <a href="#ArrayTools.standard_size"><code>standard_size</code></a>, <a href="#ArrayTools.check_size"><code>check_size</code></a>, <a href="#ArrayTools.bcastcopy"><code>bcastcopy</code></a>, <a href="#ArrayTools.bcastlazy"><code>bcastlazy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/broadcasting.jl#L80-L100">source</a></section></article><h2 id="Indexing"><a class="docs-heading-anchor" href="#Indexing">Indexing</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.ArraySize" href="#ArrayTools.ArraySize"><code>ArrayTools.ArraySize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArraySize</code></pre><p>is the union of types eligible to define array size. Calling <code>[to_size](@ref)(dims)</code> on any argument <code>dims</code> such that <code>isa(dims,ArraySize)</code> is true yields an array size in canonical form, that is an instance of <code>Dims{N}</code> which is an alias for an <code>N</code>-tuple of <code>Int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.RubberIndex" href="#ArrayTools.RubberIndex"><code>ArrayTools.RubberIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>RubberIndex</code> is the singleron type that represents any number of indices. The constant <code>..</code> is defined as <code>RubberIndex()</code> and can be used in array indexation to left and/or right justify the other indices. For instance, assuming <code>A</code> is a <code>3×4×5×6</code> array, then all the following equalities hold:</p><pre><code class="nohighlight hljs">A[..]           == A[:,:,:,:]
A[..,3]         == A[:,:,:,3]
A[2,..]         == A[2,:,:,:]
A[..,2:4,5]     == A[:,:,2:4,5]
A[2:3,..,1,2:4] == A[2:3,:,1,2:4]</code></pre><p>As you can see, the advantage of the rubber index <code>..</code> is that it automatically expands as the number of colons needed to have the correct number of indices. The expressions are also more readable.</p><p>The rubber index may also be used for setting values. For instance:</p><pre><code class="nohighlight hljs">A[..] .= 1         # to fill A with ones
A[..,3] = A[..,2]  # to copy A[:,:,:,2] in A[:,:,:,3]
A[..,3] .= A[..,2] # idem but faster
A[2,..] = A[3,..]  # to copy A[3,:,:,:] in A[2,:,:,:]
A[..,2:4,5] .= 7   # to set all elements in A[:,:,2:4,5] to 7</code></pre><p>Leading/trailing indices may be specified as Cartesian indices (of type <code>CartesianIndex</code>).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>There are two known limitations:</p><ol><li>The <code>end</code> reserved word can only be used in intervals specified <em>before</em> the rubber index but not <em>after</em>. This limitation is due to the Julia parser cannot be avoided.</li><li>At most 9 indices can be specified before the rubber index. This can be extended by editing the source code.</li></ol></div></div><p>See also: <a href="#ArrayTools.colons"><code>colons</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/rubberindex.jl#L61-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.colons" href="#ArrayTools.colons"><code>ArrayTools.colons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colons(n)</code></pre><p>yields a <code>n</code>-tuple of colons <code>:</code> (a.k.a. <code>Colon()</code>).</p><p>When <code>n</code> is known at compile time, it is faster to call:</p><pre><code class="nohighlight hljs">colons(Val(n))</code></pre><p>This method is suitable to extract sub-arrays of build views when some kind of rubber index is needed. For instance:</p><pre><code class="nohighlight hljs">slice(A::AbstractArray{T,N}, i::Integer) where {T,N} =
    A[colons(Val(N-1))..., i]</code></pre><p>defines a function that returns the <code>i</code>-th slice of <code>A</code> assuming index <code>i</code> refers the last index of <code>A</code>. Using the rubber-index <code>..</code>, a shorter definition is:</p><pre><code class="nohighlight hljs">slice(A::AbstractArray, i) = A[.., i]</code></pre><p>which is also able to deal with multiple trailing indices if <code>i</code> is a <code>CartesianIndex</code>.</p><p>See also: <code>..</code>, <a href="#ArrayTools.RubberIndex"><code>RubberIndex</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/rubberindex.jl#L7-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.IndexingType" href="#ArrayTools.IndexingType"><code>ArrayTools.IndexingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexingType(A)</code></pre><p>yields one of the singletons <code>FastIndexing()</code> or <code>AnyIndexing()</code> to indicate whether or not array <code>A</code> has standard 1-based indices and can be efficiently indexed by one integer (even if <code>A</code> is multidimensional) and column-major ordering is used to access the elements of <code>A</code>.</p><p>This method can be extended for custom array types to quickly return the correct answer.</p><p>See also <a href="#ArrayTools.is_fast_array"><code>is_fast_array</code></a>, <a href="#ArrayTools.to_fast_array"><code>to_fast_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L138-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.FastIndexing" href="#ArrayTools.FastIndexing"><code>ArrayTools.FastIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastIndexing()</code></pre><p>yields the indexing type of <em>fast</em> arrays. See <a href="#ArrayTools.IndexingType"><code>IndexingType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.AnyIndexing" href="#ArrayTools.AnyIndexing"><code>ArrayTools.AnyIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnyIndexing()</code></pre><p>yields the indexing type of <em>non-fast</em> arrays. See <a href="#ArrayTools.IndexingType"><code>IndexingType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.is_fast_array" href="#ArrayTools.is_fast_array"><code>ArrayTools.is_fast_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_fast_array(A)</code></pre><p>yields whether array <code>A</code> has standard 1-based indices and is efficiently indexed by linear indices.</p><p>Several arguments can be checked in a single call:</p><pre><code class="nohighlight hljs">is_fast_array(A, B, C, ...)</code></pre><p>is the same as:</p><pre><code class="nohighlight hljs">is_fast_array(A) &amp;&amp; is_fast_array(B) &amp;&amp; is_fast_array(C) &amp;&amp; ...</code></pre><p>See also <a href="#ArrayTools.IndexingType"><code>IndexingType</code></a>, <a href="#ArrayTools.to_fast_array"><code>to_fast_array</code></a>, <a href="#ArrayTools.is_flat_array"><code>is_flat_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L179-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.to_fast_array" href="#ArrayTools.to_fast_array"><code>ArrayTools.to_fast_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_fast_array([T=eltype(A),] A)</code></pre><p>lazily yields a <em>fast array</em> equivalent to <code>A</code> with element type <code>T</code>. A <em>fast array</em> has standard 1-based indices and is efficiently indexed by linear indices. If <code>A</code> is already a <em>fast array</em> with element type <code>T</code>, <code>A</code> is returned; otherwise, <code>A</code> is converted into an <code>Array</code> which is returned.</p><p>See also <a href="#ArrayTools.is_fast_array"><code>is_fast_array</code></a>, <a href="#ArrayTools.IndexingType"><code>IndexingType</code></a>, <a href="#ArrayTools.to_flat_array"><code>to_flat_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L203-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.to_size" href="#ArrayTools.to_size"><code>ArrayTools.to_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_size(dims)</code></pre><p>converts <code>dims</code> to an instance of <code>Dims{N}</code> which is an alias for an <code>N</code>-tuple of <code>Int</code>. Argument <code>dims</code> can be a scalar integer or a tuple of integers. Argument <code>dims</code> is returned if already of the correct type. This method may also be called as:</p><pre><code class="nohighlight hljs">to_size(dim1, dim2, ...)</code></pre><p>to let <code>to_size</code> deal with a variable number of arguments.</p><p>The union <a href="#ArrayTools.ArraySize"><code>ArraySize</code></a> matches the types of acceptable argument(s) for <code>to_size(arg)</code>: scalar integers and tuples of integers.</p><p>This method is intended for fast conversion, call <code>check_size(dims)</code> to verify that all dimensions in <code>dims</code> are nonnegative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L52-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.check_size" href="#ArrayTools.check_size"><code>ArrayTools.check_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> check_size(dims) -&gt; len</code></pre><p>checks the validity of the array size <code>dims</code> and yields the corresponding number of elements (throwing an <code>ArgumentError</code> exception if this is not the case). To be a valid array size, the values of <code>dims</code> must all be nonnegative.</p><p>See also <a href="#ArrayTools.to_size"><code>to_size</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L230-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.same_size" href="#ArrayTools.same_size"><code>ArrayTools.same_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">same_size(A, B...) -&gt; size(A)</code></pre><p>checks whether arrays <code>A</code>, <code>B</code>, etc., all have the same size which is returned. A <code>DimensionMismatch</code> exception is thrown if array sizes are not all identical.</p><p>See also <a href="#ArrayTools.same_standard_size"><code>same_standard_size</code></a>, <a href="#ArrayTools.same_axes"><code>same_axes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L192-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.same_standard_size" href="#ArrayTools.same_standard_size"><code>ArrayTools.same_standard_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">same_standard_size(A, B...) -&gt; size(A)</code></pre><p>checks whether arrays <code>A</code>, <code>B</code>, etc., all have standard indexing and the same size which is returned. If array sizes are not all identical, a <code>DimensionMismatch</code> exception is thrown. If arrays have non-standard indexing (that is indices not starting at index one), an <code>ArgumentError</code> exception is thrown.</p><p>See also <a href="#ArrayTools.standard_size"><code>standard_size</code></a>, <a href="#ArrayTools.has_standard_indexing"><code>has_standard_indexing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L173-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.standard_size" href="#ArrayTools.standard_size"><code>ArrayTools.standard_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standard_size(A) -&gt; size(A)</code></pre><p>yields the list of dimensions of <code>A</code>, that is <code>size(A)</code>, throwing an <code>ArgmentError</code> exception if <code>A</code> does not have standard 1-based indices.</p><p>See also <a href="#ArrayTools.has_standard_indexing"><code>has_standard_indexing</code></a>, <a href="#ArrayTools.same_standard_size"><code>same_standard_size</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L156-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.same_axes" href="#ArrayTools.same_axes"><code>ArrayTools.same_axes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">same_axes(A, B...) -&gt; axes(A)</code></pre><p>checks whether arrays <code>A</code>, <code>B</code>, etc., have the same axes and returns them. A <code>DimensionMismatch</code> exception is thrown if axes are not all identical.</p><p>See also <a href="#ArrayTools.same_size"><code>same_size</code></a>, <a href="#ArrayTools.all_indices"><code>all_indices</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L211-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.@assert_same_axes" href="#ArrayTools.@assert_same_axes"><code>ArrayTools.@assert_same_axes</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@assert_same_axes A B ...</code></pre><p>throws a <code>DimensionMismatch</code> exception if arrays <code>A</code>, <code>B</code>, etc. do not have the same axes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.all_indices" href="#ArrayTools.all_indices"><code>ArrayTools.all_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_indices(A...)</code></pre><p>yields an iterable object for visiting each index of array(s) <code>A</code> in an efficient manner. For array types that have opted into fast linear indexing (like <code>Array</code>), this is simply the range <code>1:length(A)</code>. For other array types, return a specialized Cartesian range to efficiently index into the array(s) with indices specified for every dimension.</p><p>If more than one <code>AbstractArray</code> argument are supplied, <code>all_indices</code> will create an iterable object that is fast for all arguments (a <code>UnitRange</code> if all inputs have fast linear indexing, a <code>CartesianIndices</code> otherwise). A <code>DimensionMismatch</code> exception is thrown if the arrays have different axes so that it is always safe to use <code>@inbounds</code> in front of a loop like:</p><p>for i in all_indices(A, B, C, D)        A[i] = B[i]*C[i] + D[i]    end</p><p>when <code>A</code>, <code>B</code> etc. are all (abstract) arrays.</p><p>This method is similar to <code>eachindex</code> except that a <code>DimensionMismatch</code> exception is thrown if arrays have different axes. For linearly indexed arrays, <code>eachindex</code> only checks that they have the same linear index range (that is the same number of elements, not the same shape).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L486-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.cartesian_indices" href="#ArrayTools.cartesian_indices"><code>ArrayTools.cartesian_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cartesian_indices(A)
cartesian_indices((n1, n2, ...))
cartesian_indices((i1:j1, i2:j2, ...))
cartesian_indices(CartesianIndex(i1, i2, ...), CartesianIndex(j1, j2, ...))
cartesian_indices(R)</code></pre><p>all yield an instance of <code>CartesianIndices</code> suitable for multi-dimensional indexing of respectively: all the indices of array <code>A</code>, a multi-dimensional array of dimensions <code>(n1,n2,...)</code>, a multi-dimensional region whose first and last indices are <code>(i1,i2,...)</code> and <code>(j1,j2,...)</code> or a Cartesian region defined by <code>R</code>, an instance of <code>CartesianIndices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L276-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.common_indices" href="#ArrayTools.common_indices"><code>ArrayTools.common_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Assuming <code>A</code> and <code>B</code> are arrays with <code>N</code> dimensions:</p><pre><code class="nohighlight hljs">common_indices(A, B) -&gt; inds</code></pre><p>yields the set of all the indices that are valid for both <code>A</code> and <code>B</code>. The result is similar to <code>axes(A)</code> or <code>axes(B)</code>, that is an <code>N</code>-tuple of integer valued unit ranges.</p><p>An offset <code>k</code> with a sign may be specified:</p><pre><code class="nohighlight hljs">common_indices(A, B, ±, k)</code></pre><p>to obtain the set of all indices <code>i</code> such that <code>A[i]</code> and <code>B[i ± k]</code> are valid and where here and above <code>±</code> is either <code>+</code> or <code>-</code>. Offset <code>k</code> can be a tuple of integers or a Cartesian index.</p><p>Arguments <code>A</code> and <code>B</code> may be both tuples of indices or index ranges or both scalar or index range which specify the size or the axes of the arrays to be indexed. This is used in the following example, where we want to do <code>A[i] = B[i]*C[i + k]</code> given the offset <code>k</code> and for all valid indices <code>i</code>:</p><pre><code class="nohighlight hljs">I = common_indices(same_axes(A, B), axes(C), +, k)
@inbounds @simd for i in CartesianIndices(I)
   A[i] = B[i]*C[i + k]
end</code></pre><p>Note that <code>same_axes(A,B)</code> is called to get the axes of <code>A</code> and <code>B</code> while asserting that they are the same, as a result no bound checking is necessary and the loop can be optimized for vectorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L330-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.has_standard_indexing" href="#ArrayTools.has_standard_indexing"><code>ArrayTools.has_standard_indexing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_standard_indexing(A)</code></pre><p>return <code>true</code> if the indices of <code>A</code> start with 1 along all axes. Can be called with multiple arguments:</p><pre><code class="nohighlight hljs">has_standard_indexing(A, B, ...)</code></pre><p>is equivalent to:</p><pre><code class="nohighlight hljs">has_standard_indexing(A) &amp;&amp; has_standard_indexing(B) &amp;&amp; ...</code></pre><p>Opposite of <code>Base.has_offset_axes</code> which is not available in version of Julia older than 0.7.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L253-L268">source</a></section></article><h2 id="Storage"><a class="docs-heading-anchor" href="#Storage">Storage</a><a id="Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Storage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.StorageType" href="#ArrayTools.StorageType"><code>ArrayTools.StorageType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StorageType(A)</code></pre><p>yields the type of storage of the elements of argument <code>A</code>. If <code>A</code> is a <em>flat</em> array, that is an array with contiguous elements in column-major order and first element at index 1, the singleton <code>FlatStorage()</code> is returned; otherwise, the singleton <code>AnyStorage()</code> is returned.</p><p>This method can be extended for custom array types to quickly return the correct answer.</p><p>See also <a href="#ArrayTools.is_flat_array"><code>is_flat_array</code></a>, <a href="#ArrayTools.to_flat_array"><code>to_flat_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.AnyStorage" href="#ArrayTools.AnyStorage"><code>ArrayTools.AnyStorage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnyStorage()</code></pre><p>yields the storage type of a <em>non-flat</em> arrays. See <a href="#ArrayTools.StorageType"><code>StorageType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.FlatStorage" href="#ArrayTools.FlatStorage"><code>ArrayTools.FlatStorage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlatStorage()</code></pre><p>yields the storage type of <em>flat</em> arrays. See <a href="#ArrayTools.StorageType"><code>StorageType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.is_flat_array" href="#ArrayTools.is_flat_array"><code>ArrayTools.is_flat_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_flat_array(A) -&gt; boolean</code></pre><p>yields whether array <code>A</code> can be indexed as a <em>flat</em> array, that is an array with contiguous elements in column-major order and first element at index 1. This also means that <code>A</code> has 1-based indices along all its dimensions.</p><p>Several arguments can be checked in a single call:</p><pre><code class="nohighlight hljs">is_flat_array(A, B, C, ...)</code></pre><p>is the same as:</p><pre><code class="nohighlight hljs">is_flat_array(A) &amp;&amp; is_flat_array(B) &amp;&amp; is_flat_array(C) &amp;&amp; ...</code></pre><p>See also <a href="#ArrayTools.StorageType"><code>StorageType</code></a>, <a href="#ArrayTools.to_flat_array"><code>to_flat_array</code></a>, <a href="#ArrayTools.is_fast_array"><code>is_fast_array</code></a>, <a href="#ArrayTools.has_standard_indexing"><code>has_standard_indexing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L81-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.to_flat_array" href="#ArrayTools.to_flat_array"><code>ArrayTools.to_flat_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_flat_array([T=eltype(A),] A)</code></pre><p>lazily yields a <em>flat</em> array based on <code>A</code>, that is an array with contiguous elements in column-major order and first element at index 1. Optional argument <code>T</code> is to specify the element type of the result. Argument <code>A</code> is returned if it is already a flat array with the requested element type; otherwise, <code>convert</code> method is called to produce the result (an <code>Array{T}</code> in that case).</p><p>See also <a href="#ArrayTools.is_flat_array"><code>is_flat_array</code></a>, <a href="#ArrayTools.to_fast_array"><code>to_fast_array</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/traits.jl#L116-L127">source</a></section></article><h2 id="Pseudo-arrays"><a class="docs-heading-anchor" href="#Pseudo-arrays">Pseudo-arrays</a><a id="Pseudo-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Pseudo-arrays" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.PseudoArrays.PseudoArray" href="#ArrayTools.PseudoArrays.PseudoArray"><code>ArrayTools.PseudoArrays.PseudoArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type <code>PseudoArray{T,N,S}</code> is to be derived by types that want to provide an array-like interface. Parameter <code>T</code> is the element type, parameter <code>N</code> is the number of dimensions and parameter <code>S</code> is the index style: <code>IndexCartesian</code> or <code>IndexLinear</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The indexing style must be part of the signature because it must be possible to call <code>IndexStyle()</code> on the data type not the instance. Another possibility would have been to have the type of the embedded array be part of the signature but this is more restrictive.</p></div></div><p>Alias <code>LinearArray{T,N}</code> is an abstract type that can be derived by types that want to provide an array-like interface with array values stored in an array whose index style is linear.</p><p>Usage can be as simple as:</p><pre><code class="nohighlight hljs">struct CustomArray{T,N,...} &lt;: LinearArray{T,N}
    arr::Array{T,N} # can be any array type with linear index style
    ...             # anything else
end

@inline Base.parent(A::CustomArray) = A.arr</code></pre><p>As a result, instances of <code>CustomArray{T,N}</code> will be seen as instances of <code>AbstractArray{T,N}</code> and behave as if they implement linear indexing. Apart from the needs to extend the <code>Base.parent</code> method, the interface to <code>LinearArray{T,N}</code> should provide any necessary methods for indexation, getting the dimensions, the element type, <em>etc.</em> for the derived custom type. You may however override these definitions by more optimized or more suitable methods specialized for your custom array-like type.</p><p>Similarly, alias <code>CartesianArray{T,N}</code> is an abstract type that can be derived by types that want to provide an array-like interface with array values stored in an array whose index style is Cartesian. For such array-like object, index checking requires an efficient implementation of the <code>Base.axes()</code> method which you may have to specialize. The default implementation is:</p><pre><code class="nohighlight hljs">@inline Base.axes(A::PseudoArray) = axes(parent(A))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/PseudoArrays.jl#L17-L59">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.all_match" href="#ArrayTools.all_match"><code>ArrayTools.all_match</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_match(val, f, args...) -&gt; bool</code></pre><p>yields as soon as possible (short-circuit) whether <code>f(arg) == val</code> for each argument <code>arg</code> in <code>args...</code>. The returned value is <code>true</code> if there are no arguments after <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/utils.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.allof" href="#ArrayTools.allof"><code>ArrayTools.allof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allof(f, args...) -&gt; Bool</code></pre><p>checks whether predicate function <code>f</code> returns <code>true</code> for all arguments in <code>args...</code>, returning <code>false</code> as soon as possible (short-circuiting).</p><pre><code class="nohighlight hljs">allof(args...) -&gt; Bool</code></pre><p>checks whether all arguments <code>args...</code> are <code>true</code>, returning <code>false</code> as soon as possible (short-circuiting). Arguments can be booleans or arrays of booleans. The latter are considered as <code>true</code> if all their elements are <code>true</code> and are considered as <code>false</code> otherwise (if any of their elements are <code>false</code>). Arguments can also be iterables to check whether all their values are <code>true</code>. An empty iterable is considered as <code>true</code>.</p><p>This method can be much faster than <code>all(f, args)</code> or <code>all(args)</code> because its result may be determined at compile time. However, <code>missing</code> values are not considered as special.</p><p>See also <code>all</code>, <a href="#ArrayTools.anyof"><code>anyof</code></a>, <a href="#ArrayTools.noneof"><code>noneof</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/utils.jl#L41-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.anyof" href="#ArrayTools.anyof"><code>ArrayTools.anyof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">anyof(f, args...) -&gt; bool</code></pre><p>checks whether predicate function <code>f</code> returns <code>true</code> for any argument <code>args...</code>, returning <code>true</code> as soon as possible (short-circuiting).</p><pre><code class="nohighlight hljs">anyof(args...) -&gt; bool</code></pre><p>checks whether all arguments <code>args...</code> are <code>true</code>, returning <code>false</code> as soon as possible (short-circuiting). Arguments can be booleans or arrays of booleans. The latter are considered as <code>true</code> if any of their elements are <code>true</code> and are considered as <code>false</code> otherwise (if all their elements are <code>false</code>). Arguments can also be iterables to check whether any of their values are <code>true</code>. An empty iterable is considered as <code>false</code>.</p><p>This method can be much faster than <code>any(f, args)</code> or <code>any(args)</code> because its result may be determined at compile time. However, <code>missing</code> values are not considered as special.</p><p>See also <code>any</code>, <a href="#ArrayTools.allof"><code>allof</code></a>, <a href="#ArrayTools.noneof"><code>noneof</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/utils.jl#L80-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.axis_limits" href="#ArrayTools.axis_limits"><code>ArrayTools.axis_limits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">axis_limits(I) = (i0,i1)</code></pre><p>yields the limits <code>i0</code> and <code>i1</code> of index range <code>I</code> as a 2-tuple of <code>Int</code>&#39;s and such that <code>i0:i1</code> represents the same indices as <code>I</code> (although not in the same order if <code>step(I) &lt; 0</code>). If <code>step(I)</code> is not equal to ±1, an <code>ArgumentError</code> exception is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L311-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.noneof" href="#ArrayTools.noneof"><code>ArrayTools.noneof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">noneof(f, args...) -&gt; bool</code></pre><p>checks whether predicate <code>f</code> returns <code>false</code> for all argument <code>args...</code>, while</p><pre><code class="nohighlight hljs">noneof(args...) -&gt; bool</code></pre><p>checks whether all argument <code>args...</code> are false.</p><p>See also <code>any</code>, <a href="#ArrayTools.allof"><code>allof</code></a>, <a href="#ArrayTools.noneof"><code>noneof</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/utils.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeUtils.promote_eltype" href="#TypeUtils.promote_eltype"><code>TypeUtils.promote_eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">promote_eltype(args...)</code></pre><p>yields the promoted element type of its arguments. Arguments <code>args...</code> may be anything implementing the <code>eltype</code> method.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.reversemap" href="#ArrayTools.reversemap"><code>ArrayTools.reversemap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reversemap(f, args)</code></pre><p>applies the function <code>f</code> to arguments <code>args</code> in reverse order and return the result. For now, the arguments <code>args</code> must be in the form of a simple tuple and the result is the tuple: <code>(f(args[end]),f(args[end-1]),...,f(args[1])</code>.</p><p>Also see: <code>map</code>, <code>ntuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/utils.jl#L133-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.split_interval" href="#ArrayTools.split_interval"><code>ArrayTools.split_interval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">split_interval(I, J, +/-, k) -&gt; Ia, Ib, Ic</code></pre><p>given unit ranges <code>I</code> and <code>J</code> and offset <code>±k</code>, yields 3 unit ranges, such that <code>Ia ∪ Ib ∪ Ic = I</code> and:</p><ul><li><p><code>∀ i ∈ Ia</code>, <code>i ± k &lt; first(J)</code>;</p></li><li><p><code>∀ i ∈ Ib</code>, <code>i ± k ∈ J</code>;</p></li><li><p><code>∀ i ∈ Ic</code>, <code>i ± k &gt; last(J)</code>.</p></li></ul><p>Unit ranges may be replaced by their first and last values:</p><pre><code class="nohighlight hljs">split_interval(first(I), last(I), first(J), last(J), +/-, k)</code></pre><p>yields the same result as above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/indexing.jl#L428-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayTools.strictmap!" href="#ArrayTools.strictmap!"><code>ArrayTools.strictmap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strictmap!(f, dst, src) -&gt; dst
strictmap!(dst, f, src) -&gt; dst</code></pre><p>does <code>dst[i] = f(src[i])</code> for all indices <code>i</code> and returns <code>dst</code>. Arguments <code>dst</code> and <code>src</code> must have the same axes.</p><p>Except for the strict condition on the axes, this method is similar to <code>map!(f,dst,src)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/ArrayTools.jl/blob/f6e322a3e04fea2919bcf45760fb53ef5ad3a62e/src/utils.jl#L146-L156">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../broadcasting/">« Broadcasting of arrays</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 15 May 2024 10:56">Wednesday 15 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
